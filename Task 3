#ifdef __APPLE__
    #include <GLUT/glut.h>
#else
    #include <GL/glut.h>
#endif

#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

// for multiple lines
struct LineSeg {
    float x1, y1;
    float x2, y2;
};

//user input
float g_xmin_w, g_ymin_w, g_xmax_w, g_ymax_w;  // clip window
vector<LineSeg> g_lines;                       // all input lines

/
struct ClippedSeg {
    bool visible;
    float cx1, cy1;
    float cx2, cy2;
};
vector<ClippedSeg> g_clipped;

//helpers
void drawLine(float x1, float y1, float x2, float y2)
{
    glBegin(GL_LINES);
    glVertex2f(x1, y1);
    glVertex2f(x2, y2);
    glEnd();
}

void drawClipWindow(float xmin_, float ymin_, float xmax_, float ymax_)
{
    glBegin(GL_LINE_LOOP);
    glVertex2f(xmin_, ymin_);
    glVertex2f(xmax_, ymin_);
    glVertex2f(xmax_, ymax_);
    glVertex2f(xmin_, ymax_);
    glEnd();
}

// Liangâ€“Barsky clipping algo
// at least partially visible = true;
// outputs clipped endpoints in cx1,cy1,cx2,cy2
bool liangBarskyClip(
    float xmin_, float ymin_, float xmax_, float ymax_,
    float x1, float y1, float x2, float y2,
    float &cx1, float &cy1, float &cx2, float &cy2)
{
    float dx = x2 - x1;
    float dy = y2 - y1;

    float p[4], q[4];
    p[0] = -dx;        q[0] = x1 - xmin_;   // left
    p[1] =  dx;        q[1] = xmax_ - x1;   // right
    p[2] = -dy;        q[2] = y1 - ymin_;   // bottom
    p[3] =  dy;        q[3] = ymax_ - y1;   // top

    float u1 = 0.0f;
    float u2 = 1.0f;

    for (int k = 0; k < 4; k++)
    {
        if (p[k] == 0.0f)
        {
            // Parallel 
            if (q[k] < 0.0f)
            {
                // Parallel and outside = reject
                return false;
            }
            // else parallel but inside = okay
        }
        else
        {
            float r = q[k] / p[k];

            if (p[k] < 0.0f)
            {
                // entering boundary = raise lower bound
                if (r > u1) u1 = r;
            }
            else // p[k] > 0.0f
            {
                // leaving boundary = lower upper bound
                if (r < u2) u2 = r;
            }

            //reject
            if (u1 > u2)
                return false;
        }
    }

    cx1 = x1 + u1 * dx;
    cy1 = y1 + u1 * dy;
    cx2 = x1 + u2 * dx;
    cy2 = y1 + u2 * dy;
    return true;
}

void display()
{
    glClear(GL_COLOR_BUFFER_BIT);

    // clipping window
    glColor3f(1.0f, 1.0f, 1.0f);
    drawClipWindow(g_xmin_w, g_ymin_w, g_xmax_w, g_ymax_w);

    // unclipped segments in red
    glColor3f(1.0f, 0.0f, 0.0f);
    for (size_t i = 0; i < g_lines.size(); i++)
    {
        drawLine(g_lines[i].x1, g_lines[i].y1,
                 g_lines[i].x2, g_lines[i].y2);
    }

    //clipped segments in green
    glColor3f(0.0f, 1.0f, 0.0f);
    for (size_t i = 0; i < g_clipped.size(); i++)
    {
        if (g_clipped[i].visible)
        {
            drawLine(g_clipped[i].cx1, g_clipped[i].cy1,
                     g_clipped[i].cx2, g_clipped[i].cy2);
        }
    }

    glFlush();
}

void initGL()
{
        glClearColor(0.0, 0.0, 0.0, 1.0);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

        gluOrtho2D(0.0, 800.0, 0.0, 600.0);
}

int main(int argc, char **argv)
{
    //user input
    cout << "Enter clipping window (xmin ymin xmax ymax): ";
    cin  >> g_xmin_w >> g_ymin_w >> g_xmax_w >> g_ymax_w;

    //line segments
    int n;
    cout << "Enter number of line segments: ";
    cin  >> n;

    g_lines.resize(n);

    for (int i = 0; i < n; i++)
    {
        cout << "Enter line " << i+1
             << " as:  x1 y1 x2 y2 : ";
        cin >> g_lines[i].x1
            >> g_lines[i].y1
            >> g_lines[i].x2
            >> g_lines[i].y2;
    }

        g_clipped.resize(n);
    for (int i = 0; i < n; i++)
    {
        float cx1, cy1, cx2, cy2;
        bool vis = liangBarskyClip(
            g_xmin_w, g_ymin_w, g_xmax_w, g_ymax_w,
            g_lines[i].x1, g_lines[i].y1,
            g_lines[i].x2, g_lines[i].y2,
            cx1, cy1, cx2, cy2
        );

        g_clipped[i].visible = vis;
        g_clipped[i].cx1 = cx1;
        g_clipped[i].cy1 = cy1;
        g_clipped[i].cx2 = cx2;
        g_clipped[i].cy2 = cy2;
    }

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize(800, 600);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Liang-Barsky Line Clipping (Multiple Segments)");

    initGL();
    glutDisplayFunc(display);

    glutMainLoop();
    return 0;
}
